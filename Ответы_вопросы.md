# Ответы на вопросы

## 1) Что такое ООП?
Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции "объектов", которые представляют собой экземпляры классов. Классы определяют свойства (данные) и поведение (методы) объектов. ООП направлено на повышение модульности, переиспользуемости и читаемости кода через четыре основных принципа:

Инкапсуляция: Сокрытие внутренней реализации объекта и предоставление доступа к данным только через публичные методы (например, геттеры и сеттеры).
Наследование: Возможность создавать новые классы на основе существующих, наследуя их свойства и методы.
Полиморфизм: Способность объектов разных классов обрабатываться единообразно через общий интерфейс или суперкласс.
Абстракция: Упрощение сложных систем путём выделения только значимых характеристик объекта, скрывая детали реализации.
Пример из кода выше: класс FibonacciGenerator инкапсулирует логику генерации чисел Фибоначчи, предоставляя только метод generate_fibonacci.

## 2) Магическое число 7 Миллера
Магическое число 7 (±2) — это концепция из психологии, предложенная Джорджем Миллером в 1956 году. Она утверждает, что кратковременная память человека способна удерживать одновременно 5–9 элементов информации. В IT это влияет на проектирование интерфейсов, алгоритмов и структур данных.

Примеры из IT:
Меню интерфейса: В большинстве приложений (например, Microsoft Word) в верхнем меню не более 7 пунктов, чтобы пользователь мог быстро их обработать.
Чанкинг в базах данных: При выводе данных (например, в таблице) часто показывают 5–9 строк, чтобы не перегружать восприятие.
Ограничение параметров функции: В Python рекомендуется не более 7 аргументов в функции (согласно PEP 8), чтобы код оставался читаемым.
Дизайн дашбордов: В аналитических системах (например, Tableau) на одном экране обычно 5–7 ключевых метрик.
Списки в UI: В выпадающих списках (dropdown) часто ограничивают до 7 элементов без прокрутки.
Кэш процессора: Размер кэш-линий часто оптимизируется под кратное 7 количество операций для быстрого доступа.
Тестирование UX: При юзабилити-тестировании обычно достаточно 5–7 пользователей, чтобы выявить 85% проблем (принцип близкий к Миллеру).
## 3) Энтропия ПО
Энтропия программного обеспечения — это мера хаоса или беспорядка в коде, которая увеличивается со временем из-за изменений, усложнения структуры и накопления технического долга. Высокая энтропия приводит к трудностям в поддержке и масштабировании.

Неэнтропийные меры (меры против хаоса):
Рефакторинг: В коде выше я разбил функционал на классы (FibonacciGenerator, PalindromeChecker), что упрощает поддержку.
Использование паттернов проектирования: Например, применение MVC в REST-сервисе (app.py) разделяет логику и представление.
Автоматическое тестирование: Unit-тесты (test_fibonacci.py, test_api.py) предотвращают регрессии при изменениях.
Документация кода: Комментарии и типизация в коде (например, def generate_fibonacci(n: int) -> List[int]) снижают неопределенность.
Контроль версий: Использование Git (как в инструкции для GitHub) позволяет отслеживать изменения и избегать потери структуры.

## 4) 5 признаков сложной системы по Гради Бучу
Гради Буч выделяет 5 признаков сложных систем: многосоставность, взаимосвязанность, неоднородность, эмерджентность, адаптивность.

1. Многосоставность (наличие множества компонентов):
В REST-сервисе (app.py) есть отдельные модули для Фибоначчи, палиндромов и списка.
Unit-тесты разделены на файлы (test_fibonacci.py, test_linked_list.py) для каждого компонента.
2. Взаимосвязанность (компоненты влияют друг на друга):
Класс LinkedList использует Node для построения структуры, изменение в Node влияет на весь список.
REST API (app.py) зависит от логики в fibonacci.py и других модулях.
3. Неоднородность (разнообразие компонентов):
Код сочетает алгоритмы (Фибоначчи), структуры данных (связный список) и веб-сервис (FastAPI).
Тесты включают как юнит-тесты, так и API-тесты с разными подходами.
4. Эмерджентность (непредсказуемые свойства системы):
При развороте списка (reverse) в LinkedList поведение зависит от входных данных, что может привести к неожиданным ошибкам (например, пустой список).
REST-сервис может неожиданно масштабироваться при большом количестве запросов, если не оптимизировать.
5. Адаптивность (способность подстраиваться):
Обработка исключений в generate_fibonacci позволяет адаптироваться к некорректным входным данным.
Модульная структура кода позволяет легко добавить новый эндпоинт в app.py.

## 5) Закон иерархических компенсаций Седова
Закон иерархических компенсаций Седова гласит, что в сложных системах недостатки одного уровня компенсируются преимуществами другого уровня для сохранения общей устойчивости.

Исторические примеры в IT:
Ассемблер vs Высокоуровневые языки (1950-е):
Недостаток: Ассемблер был сложен и требователен к деталям.
Компенсация: Появление языков вроде Fortran и C упростило разработку на более высоком уровне.
Монолитные системы vs Микросервисы (2000-е):
Недостаток: Монолиты трудно масштабировать.
Компенсация: Микросервисы (как в Netflix) распределяют нагрузку на уровень архитектуры.
Ручное управление памятью vs Сборщики мусора (1990-е):
Недостаток: В C/C++ управление памятью приводило к утечкам.
Компенсация: Java и Python ввели сборщики мусора на уровне языка.
Локальные сервера vs Облачные технологии (2010-е):
Недостаток: Локальные сервера требовали больших затрат на обслуживание.
Компенсация: AWS и Google Cloud перенесли управление на уровень инфраструктуры.
Статические сайты vs Динамические фреймворки (1990-е–2000-е):
Недостаток: HTML-страницы были ограничены в интерактивности.
Компенсация: JavaScript и фреймворки (React, Angular) добавили динамику на уровне клиентских приложений.
